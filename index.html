<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"># React testing workshop 🧪

Bekk React faggruppe - September 2020
</script></section><section  data-markdown><script type="text/template">
## Plan for workshop 📋

- testing av React-komponenter
- jest
- react testing library
- mocking med jest.mock og fetch-mock
</script></section><section  data-markdown><script type="text/template">
### Hva er en god test?

Egenskaper av en god test

- Rask
- Isolert
- Forutsigtbar og repeterbar
- Uavhengig av implementasjon i koden som testes
- Self-Checking (suksess ✅ eller feil ❌)

<aside class="notes"><p>enklere at refaktorere kode, dytter deg mot beste praksis for universell utforming, fokuserer på brukeren. Bibliotek som <code>@testing-library/react</code> hjelper deg med å skrive gode tester, og gjør det vanskelig å skrive dårlige tester</p>
</aside></script></section><section  data-markdown><script type="text/template">
### Et eksempel

En enkel tellere:

```JSX
function Counter() = {
  const [count, setCount] = useState(0);
  return {
    <div>
      <p>Current count: {count}</p>
      <button onClick={setCount(count+1)} >+</button>
    </div>
  }
}

```

Test:

```JSX
test("standardverdi for telleren er 0", () => {
  const { getByText } = render(Counter);
  const count = getByText("Current count: 0");
  expect(count).toBeInTheDocument();
});
```
</script></section><section  data-markdown><script type="text/template">
### Et annet eksempel

En enkel tellere:

```JSX
function Counter() = {
  const [count, setCount] = useState(0);
  return {
    <div>
      <p>Current count: {count}</p>
      <button onClick={setCount(count+1)} >+</button>
    </div>
  }
}

```

Test:

```JSX
test("telleren skal øke med en når den klikkes", () => {
  const { getByText, getByRole } = render(Counter);
  expect(getByText("Current count: 0")).toBeInTheDocument();

  const button = getByRole("button", {name: "+"});
  userEvent.click(button);
  expect(getByText("Current count: 1")).toBeInTheDocument();
});
```
</script></section><section  data-markdown><script type="text/template">
### Noen viktige funksjoner

- `render`
- `userEvent`
- `expect`

```JSX
test("sjekk at teksten vinker", () => {
  const { getByText } = render(<p>Hej!👋</p>); // <-- render
  const tekst = getByText(/hej/i); // <-- query eksponert av render
  userEvent.click(tekst); // <-- userEvent
  expect(tekst).toBeInTheDocument(); // <-- expect
});
```
</script></section><section  data-markdown><script type="text/template">
### render

```JSX
import { render } from "@testing-library/react";

const { container, getByText, etc... } = render(Component):
```

- render eksponerer alle queries som kan brukes for å finne elementer i `document.body`.

```jsx
const { getByText, getByRole, ... } = render(Component):
const input = getByRole("input");
const button = getByRole("button", {name: /klikk her/i});
const listElements = getAllByRole("listitem");
const label = getByText("Vem er du?");
const input = getByLabelText("Vem er du?");
```

- og `container` som er en referens til DOM-noden der komponenten finnes

- etc..
</script></section><section  data-markdown><script type="text/template">
### jest expect

- Brukes for å evaluere at resultatet er some forventet

- Testene feile og gi en god tilbakemelding hvis expect ikke innholder forventet verdi

- Bruk ikke bare `.toBe` uten test å finne ut korrekt "matcher"

```JSX
expect(result).toBe(expected);
expect(result).not.toBe(expected);
expect(element).toBeInTheDocument();

expect(result.value).toBe(expected);  ❌
expect(result).toHaveValue(expected); ✅

expect(result.length).toBe(expected);  ❌
expect(result).toHaveLength(expected); ✅

```
</script></section><section  data-markdown><script type="text/template">
### user Event 👴

- `userEvent` simulerer noen som bruker komponenten

```JSX
test("typing in the input should change its value", () => {
  const { getByRole } = render(<input type="checkbox" />);

  const checkbox = getByRole("checkbox");
  expect(checkbox).toBeChecked();

  userEvent.click(checkbox);
  exect(checkbox).not.toBeChecked();
});
```

API:

```JSX
userEvent.click(element)
userEvent.type(element, text)
userEvent.clear(element)
etc...
```
</script></section><section  data-markdown><script type="text/template">
### Component testing Sammenfattet

```JSX
test("her tester jeg noe", () => {
  // Legg til komponenten til dokument.body med render
  // hent ut queries du trenger
  const {debug, queries} = render(MinKomponent)
  // Bruk debug() for å printe ut DOM:en når du skriver tester
  debug()
  // bruk en query, vanligvis getByRole, for at finne et element
  const knapp = getByRole("button", {name: /knappenavn/i})
  // Bruk userEvent for å samhandle med en del av komponenten
  userEvent.click(knapp);
  // Sjekk at resultatet er som forventet
  // i dette tilfellet skulle noen tekst komme opp ved klikk
  const tekst = getByText("Du vant da du klikket på knappen!")
  expect(tekst).toBeInTheDocument();
})
```
</script></section><section  data-markdown><script type="text/template">
## Mocking 🦸‍♀️
</script></section><section  data-markdown><script type="text/template">
### Hvorofor trenger vi mock? 🤔

En applikasjon er ofte avhengig av eksterne ressurser. Det kan være et API som nås over nettverket, en fil på filsystem eller en system ressurs (f.eks. dagensdato)

Disse eksterne ressursene skaper uforutsigtbarhet ved testing. Vi vil ikke at testene våre feiler fordi en ekstern ressurs ikke er tilgjengelig når testen kjører.
</script></section><section  data-markdown><script type="text/template">
> Mocking is the action of creating objects that mimic the behavior of real objects in controlled ways

<span style="font-family:serif; font-style:italic; font-size:0.5em;">Kilde: "Mock object" - Wikipedia</span>
</script></section><section  data-markdown><script type="text/template">
### Mocking med jest

👉 Vi bruker `jest.mock` for å mocke funksjoner av en modul med uforutsigtbare avhengigheter

For eksempel: en funksjon `getTodaysDate()` som ligger i en modul `date-utils` og henter system dato
</script></section><section  data-markdown><script type="text/template">
Kode 🧑🏿‍💻

```js
// Her oppretter vi en mock av getTodaysDate()
// og spesifiserer hva den skal returnere
jest.mock("../../utils/date-utils", () => {
  return {
    getTodaysDate: jest.fn(() => "Monday"),
  };
});
// functionToTest() har avhengighet til getTodaysDate()
// og kommer til å bruke mock 👆i neste instruksjonen
const result = functionToTest();

// da kan vi skrive en forutsigtbar test
// som sjekker verdi av "result"
```
</script></section><section  data-markdown><script type="text/template">
### Mocke http kall med fetch-mock 🛠

Før vi ser på kode som bruker `fetch-mock` skal vi vise noen illustrasjoner som beskriver hvordan en React app interagerer med nettverket.

💡 På siste illustrasjon viser vi hvor vi kan posisjonere en mock for å kunne kjøre applikasjon uten backend
</script></section><section  data-markdown><script type="text/template">
##### Hvordan fungerer en React-app med en backend?

![Skjema av en real-world React app](https://github.com/bekk/react-test-workshop/raw/master/presentasjon/img/mocking-schema-1.png)
En React app med avhengigheter til et eksternt API
</script></section><section  data-markdown><script type="text/template">
##### Hvordan kjøres applikasjon lokalt?

![Skjema av en real-world React app](https://github.com/bekk/react-test-workshop/raw/master/presentasjon/img/mocking-schema-2.png)
Todo-list sammen med _server.js_
</script></section><section  data-markdown><script type="text/template">
##### Hvordan kan vi kjøre lokalt med en mock?

![Skjema av en real-world React app](https://github.com/bekk/react-test-workshop/raw/master/presentasjon/img/mocking-schema-3.png)
Todo-list med mock
</script></section><section  data-markdown><script type="text/template">
### fetch-mock 🛠

> The fetch-mock library will let you simulate and manage interactions with other applications by intercepting all API calls done with fetch

```JSX
import fetchMock from "fetch-mock";

fetchMock.get(
  "express:/todolist",
  (url) => {
    return {
      todoList: [{ text: "Hello I'm MOCK", id: "1" }],
    };
  }
);
```
</script></section><section  data-markdown><script type="text/template">
### bruk av fetch-mock i oppgaver

Vi bruker vi `fetch-mock` for to forskjellige hensikt i denne workshoppen

👉 i **_oppgave 3_** skal du bruke `fetch-mock` for å kunne teste en funksjon som sender request til backend

👉 i **_oppgave 4_** ønsker vi å kjøre applikasjon lokalt uten `server.js`. Da skal du kode en mock med `fetch-mock` som "oppfører seg" som backend
</script></section><section  data-markdown><script type="text/template">
## Åpne spørsmål

- Hvordan tester ni frontend på projekt idag?

- Test driven development?

- Si noe om testing on commit
</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
