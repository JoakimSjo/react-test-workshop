<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"># React testing workshop 🧪

Bekk React faggruppe - September 2020
</script></section><section  data-markdown><script type="text/template">
## Plan for workshop 📋

- testing av React-komponenter
- jest
- react testing library
- mocking med jest.mock og fetch-mock
</script></section><section  data-markdown><script type="text/template">
### Hva er en god test?

Egenskaper av en god test

- Rask
- Isolert
- Forutsigtbar og repeterbar
- Uavhengig av implementasjon i koden som testes
- Self-Checking (suksess ✅ eller feil ❌)
</script></section><section  data-markdown><script type="text/template">
## Testing av React komponenter
</script></section><section  data-markdown><script type="text/template">
### React testing library

> The @testing-library family of packages helps you test UI components in a user-centric way.

```JSX
import React from "react";
import { render } from "@testing-library/react";

test("paragraph renders text", () => {
  const { getByText } = render(
    <p>Välkommen!</p>
  );
  const paragraph = getByText(/välkommen/i);
  expect(paragraph).toBeInTheDocument();
});

```

<aside class="notes"><p>speaker notes FTW!</p>
</aside></script></section><section  data-markdown><script type="text/template">
### render

```JSX
const {/\* \*/} = render(Component):
```

- all the queries from DOM Testing Library

  - ByText
  - ByLabelText
  - ByPlaceholderText
  - ByTestId
  - ...

- container reference to the DOM node where the component is mounted
</script></section><section  data-markdown><script type="text/template">
### jest expect

- test

- `expect(result).toBe(expected)`
</script></section><section  data-markdown><script type="text/template">
### fire event
</script></section><section  data-markdown><script type="text/template">
## Mocking 🦸‍♀️
</script></section><section  data-markdown><script type="text/template">
### Hvorofor trenger vi mock? 🤔

En applikasjon er ofte avhengig av eksterne ressurser. Det kan være et API som nås over nettverket, en fil på filsystem eller en system ressurs (f.eks. dagensdato)

Disse eksterne ressursene skaper uforutsigtbarhet ved testing. Vi vil ikke at testene våre feiler fordi en ekstern ressurs ikke er tilgjengelig når testen kjører.
</script></section><section  data-markdown><script type="text/template">
> Mocking is the action of creating objects that mimic the behavior of real objects in controlled ways
</script></section><section  data-markdown><script type="text/template">
### Mocking med jest

👉 Vi bruker `jest.mock` for å mocke funksjoner av en modul med uforutsigtbare avhengigheter

For eksempel: en funksjon `getTodaysDate()` som ligger i en modul `date-utils` og henter system dato
</script></section><section  data-markdown><script type="text/template">
Kode 🧑🏿‍💻

```js
// Her oppretter vi en mock av getTodaysDate()
// og spesifiserer hva den skal returnere
jest.mock("../../utils/date-utils", () => {
  return {
    getTodaysDate: jest.fn((lang: string) => "Monday"),
  };
});
// functionToTest() har avhengighet til getTodaysDate()
// og kommer til å bruke mock 👆i neste instruksjonen
const result = functionToTest();

// da kan vi skrive en forutsigtbar test
// som sjekker verdi av "result"
```
</script></section><section  data-markdown><script type="text/template">
### Mocke http kall med fetch-mock 🛠

Før vi ser på kode som bruker `fetch-mock` skal vi vise noen illustrasjoner som beskriver hvordan en React app interagerer med nettverket.

💡 På siste illustrasjon viser vi hvor vi kan posisjonere en mock for å kunne kjøre applikasjon uten backend
</script></section><section  data-markdown><script type="text/template">
##### Hvordan fungerer en React-app med en backend?

![Skjema av en real-world React app](/img/mocking-schema-1.png)
En React app med avhengigheter til et eksternt API
</script></section><section  data-markdown><script type="text/template">
##### Hvordan kjøres applikasjon lokalt?

![Skjema av en real-world React app](/img/mocking-schema-2.png)
Todo-list sammen med _server.js_
</script></section><section  data-markdown><script type="text/template">
##### Hvordan kan vi kjøre lokalt med en mock?

![Skjema av en real-world React app](/img/mocking-schema-3.png)
Todo-list med mock
</script></section><section  data-markdown><script type="text/template">
### fetch-mock 🛠

> The fetch-mock library will let you simulate and manage interactions with other applications by intercepting all API calls done with fetch

```JSX
import fetchMock from "fetch-mock";

fetchMock.get(
  "express:/todolist",
  (url) => {
    return {
      todoList: [{ text: "Hello I'm MOCK", id: "1" }],
    };
  }
);
```
</script></section><section  data-markdown><script type="text/template">
### bruk av fetch-mock i oppgaver

Vi bruker vi `fetch-mock` for to forskjellige hensikt i denne workshoppen

👉 i **_oppgave 3_** skal du bruke `fetch-mock` for å kunne teste en funksjon som sender request til backend

👉 i **_oppgave 4_** ønsker vi å kjøre applikasjon lokalt uten `server.js`. Da skal du kode en mock med `fetch-mock` som "oppfører seg" som backend
</script></section><section  data-markdown><script type="text/template">
## Åpne spørsmål

- Hvordan tester ni frontend på projekt idag?

- Test driven development?

- Si noe om testing on commit
</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
